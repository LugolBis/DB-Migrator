{"tables": [{"table_name": "auteurs", "columns": [{"column_name": "auteur_id", "data_type": "integer", "is_nullable": "NO", "column_default": "nextval('auteurs_auteur_id_seq'::regclass)", "primary_key": true, "foreign_key": null}, {"column_name": "nom", "data_type": "character varying", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "nationalite", "data_type": "character varying", "is_nullable": "YES", "column_default": null, "primary_key": null, "foreign_key": null}]}, {"table_name": "categories", "columns": [{"column_name": "categorie_id", "data_type": "integer", "is_nullable": "NO", "column_default": "nextval('categories_categorie_id_seq'::regclass)", "primary_key": true, "foreign_key": null}, {"column_name": "nom", "data_type": "character varying", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": null}]}, {"table_name": "editeurs", "columns": [{"column_name": "editeur_id", "data_type": "integer", "is_nullable": "NO", "column_default": "nextval('editeurs_editeur_id_seq'::regclass)", "primary_key": true, "foreign_key": null}, {"column_name": "nom", "data_type": "character varying", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "adresse", "data_type": "character varying", "is_nullable": "YES", "column_default": null, "primary_key": null, "foreign_key": null}]}, {"table_name": "livres", "columns": [{"column_name": "livre_id", "data_type": "integer", "is_nullable": "NO", "column_default": "nextval('livres_livre_id_seq'::regclass)", "primary_key": true, "foreign_key": null}, {"column_name": "titre", "data_type": "character varying", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "auteur_id", "data_type": "integer", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": [{"constraint_name": "livres_auteur_id_fkey", "referenced_table": "auteurs", "referenced_column": "auteur_id"}]}, {"column_name": "date_publication", "data_type": "date", "is_nullable": "YES", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "isbn", "data_type": "character varying", "is_nullable": "YES", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "categorie_id", "data_type": "integer", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": [{"constraint_name": "livres_categorie_id_fkey", "referenced_table": "categories", "referenced_column": "categorie_id"}]}, {"column_name": "editeur_id", "data_type": "integer", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": [{"constraint_name": "livres_editeur_id_fkey", "referenced_table": "editeurs", "referenced_column": "editeur_id"}]}]}, {"table_name": "exemplaires", "columns": [{"column_name": "exemplaire_id", "data_type": "integer", "is_nullable": "NO", "column_default": "nextval('exemplaires_exemplaire_id_seq'::regclass)", "primary_key": true, "foreign_key": null}, {"column_name": "livre_id", "data_type": "integer", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": [{"constraint_name": "exemplaires_livre_id_fkey", "referenced_table": "livres", "referenced_column": "livre_id"}]}, {"column_name": "statut", "data_type": "character varying", "is_nullable": "YES", "column_default": null, "primary_key": null, "foreign_key": null}]}, {"table_name": "utilisateurs", "columns": [{"column_name": "utilisateur_id", "data_type": "integer", "is_nullable": "NO", "column_default": "nextval('utilisateurs_utilisateur_id_seq'::regclass)", "primary_key": true, "foreign_key": null}, {"column_name": "prenom", "data_type": "character varying", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "nom", "data_type": "character varying", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "email", "data_type": "character varying", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": null}, {"column_name": "date_inscription", "data_type": "date", "is_nullable": "YES", "column_default": "CURRENT_DATE", "primary_key": null, "foreign_key": null}]}, {"table_name": "emprunts", "columns": [{"column_name": "emprunt_id", "data_type": "integer", "is_nullable": "NO", "column_default": "nextval('emprunts_emprunt_id_seq'::regclass)", "primary_key": true, "foreign_key": null}, {"column_name": "utilisateur_id", "data_type": "integer", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": [{"constraint_name": "emprunts_utilisateur_id_fkey", "referenced_table": "utilisateurs", "referenced_column": "utilisateur_id"}]}, {"column_name": "exemplaire_id", "data_type": "integer", "is_nullable": "NO", "column_default": null, "primary_key": null, "foreign_key": [{"constraint_name": "emprunts_exemplaire_id_fkey", "referenced_table": "exemplaires", "referenced_column": "exemplaire_id"}]}, {"column_name": "date_emprunt", "data_type": "date", "is_nullable": "NO", "column_default": "CURRENT_DATE", "primary_key": null, "foreign_key": null}, {"column_name": "date_retour", "data_type": "date", "is_nullable": "YES", "column_default": null, "primary_key": null, "foreign_key": null}]}], "triggers": [{"trigger_name": "disponible", "event": "CREATE TRIGGER disponible BEFORE INSERT ON public.emprunts FOR EACH ROW EXECUTE FUNCTION verifier_disponibilite()", "table_name": "emprunts"}], "procedures": [{"procedure_name": "retour", "return_type": "void", "arguments": null, "definition": "CREATE OR REPLACE PROCEDURE public.retour(IN exemplaire_id integer)\n LANGUAGE plpgsql\nAS $procedure$\nbegin\n    update exemplaires set statut=\"disponible\" where exemplaire_id=exemplaire_id;\nend;\n$procedure$\n"}], "functions": [{"function_name": "export_db_to_json", "return_type": "jsonb", "arguments": "jsonb", "definition": "CREATE OR REPLACE FUNCTION public.export_db_to_json()\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  rec record;\n  table_json jsonb;\n  result jsonb := '{}'::jsonb;\nBEGIN\n  FOR rec IN\n    SELECT table_schema, table_name\n    FROM information_schema.tables\n    WHERE table_schema NOT IN ('pg_catalog', 'information_schema')\n      AND table_name NOT IN ('users', 'technical_details', 'metadata')\n  LOOP\n    EXECUTE format(\n      'SELECT COALESCE(JSONB_AGG(ROW_TO_JSON(t)::jsonb), ''[]''::jsonb) FROM %I.%I t',\n      rec.table_schema, rec.table_name\n    )\n    INTO table_json;\n    \n    result := result || jsonb_build_object(rec.table_name, table_json);\n  END LOOP;\n  \n  RETURN result;\nEND;\n$function$\n"}, {"function_name": "verifier_disponibilite", "return_type": "trigger", "arguments": "trigger", "definition": "CREATE OR REPLACE FUNCTION public.verifier_disponibilite()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    DISPONIBILITE varchar(20);\nbegin\n    select statut into DISPONIBILITE\n    from exemplaires\n    where exemplaire_id = new.exemplaire_id;\n\n    if DISPONIBILITE = 'disponible' then\n        update exemplaires \n        set statut = 'emprunt\u00e9' \n        where exemplaire_id = new.exemplaire_id;\n    else\n        RAISE EXCEPTION 'The book % is already borrowed.', new.exemplaire_id;\n    end if;\n\n    return new;\nend;\n$function$\n"}, {"function_name": "export_db_to_csv", "return_type": "text", "arguments": "text", "definition": "CREATE OR REPLACE FUNCTION public.export_db_to_csv()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n    table_name TEXT;\n    export_query TEXT;\n    export_result TEXT := '';\nBEGIN\n    FOR table_name IN \n        SELECT tablename FROM pg_tables WHERE schemaname = 'public'\n    LOOP\n        export_query := format(\n            'COPY (SELECT * FROM public.%I) TO STDOUT WITH CSV HEADER DELIMITER '','';', \n            table_name\n        );\n        export_result := export_result || export_query || '\n';\n    END LOOP;\n    RETURN export_result;\nEND $function$\n"}, {"function_name": "export_db_to_csv", "return_type": "void", "arguments": "void", "definition": "CREATE OR REPLACE FUNCTION public.export_db_to_csv(commands_file text, export_path text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n    table_name TEXT;\n    export_command TEXT;\n    file_output TEXT := '';\nBEGIN\n    FOR table_name IN \n        SELECT tablename FROM pg_tables WHERE schemaname = 'public'\n    LOOP\n        export_command := format(\n            '\\copy public.%I TO ''%s/%I.csv'' WITH CSV HEADER DELIMITER '','';\\n', \n            table_name, export_path, table_name\n        );\n        file_output := file_output || export_command;\n    END LOOP;\n    \n    -- Sauvegarde des commandes dans un fichier texte (n\u00e9cessite PostgreSQL 16+)\n    PERFORM pg_write_file(commands_file, file_output);\nEND $function$\n"}, {"function_name": "export_fk_relationships", "return_type": "jsonb", "arguments": "jsonb", "definition": "CREATE OR REPLACE FUNCTION public.export_fk_relationships()\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    result jsonb := '{}'::jsonb;\n    fk_record RECORD;\n    source_pk_cols TEXT;\n    referenced_pk_cols TEXT;\n    join_conditions TEXT;\n    query TEXT;\n    pairs JSONB;\n    key_name TEXT;\nBEGIN\n    FOR fk_record IN\n        SELECT\n            tc.table_name as source_table,\n            ccu.table_name as referenced_table,\n            kcu.column_name as fk_column,\n            ccu.column_name as referenced_column,\n            tc.constraint_name\n        FROM \n            information_schema.table_constraints AS tc \n            JOIN information_schema.key_column_usage AS kcu\n              ON tc.constraint_name = kcu.constraint_name\n            JOIN information_schema.constraint_column_usage AS ccu\n              ON tc.constraint_name = ccu.constraint_name\n        WHERE \n            tc.constraint_type = 'FOREIGN KEY'\n    LOOP\n        EXECUTE format(\n            'SELECT string_agg(column_name, '','') \n             FROM information_schema.key_column_usage \n             WHERE table_name = %L \n             AND constraint_name IN (\n                 SELECT constraint_name \n                 FROM information_schema.table_constraints \n                 WHERE table_name = %L \n                 AND constraint_type = ''PRIMARY KEY''\n             )',\n            fk_record.source_table,\n            fk_record.source_table\n        ) INTO source_pk_cols;\n\n        EXECUTE format(\n            'SELECT string_agg(column_name, '','') \n             FROM information_schema.key_column_usage \n             WHERE table_name = %L \n             AND constraint_name IN (\n                 SELECT constraint_name \n                 FROM information_schema.table_constraints \n                 WHERE table_name = %L \n                 AND constraint_type = ''PRIMARY KEY''\n             )',\n            fk_record.referenced_table,\n            fk_record.referenced_table\n        ) INTO referenced_pk_cols;\n\n        join_conditions := format(\n            '%I.%I = %I.%I',\n            fk_record.source_table,\n            fk_record.fk_column,\n            fk_record.referenced_table,\n            fk_record.referenced_column\n        );\n\n        query := format(\n            'SELECT jsonb_agg(jsonb_build_array(source_pk, referenced_pk)) \n             FROM (\n                 SELECT \n                     (%I.%I) as source_pk,\n                     (%I.%I) as referenced_pk \n                 FROM \n                     %I \n                     JOIN %I ON %s\n             ) sub',\n            fk_record.source_table, source_pk_cols,\n            fk_record.referenced_table, referenced_pk_cols,\n            fk_record.source_table,\n            fk_record.referenced_table,\n            join_conditions\n        );\n\n        EXECUTE query INTO pairs;\n        \n        key_name := format('%s_REF_%s',UPPER(fk_record.source_table),UPPER(fk_record.referenced_table));\n        \n        result := result || jsonb_build_object(key_name, pairs)::jsonb;\n    END LOOP;\n\n    RETURN result;\nEND;\n$function$\n"}]}